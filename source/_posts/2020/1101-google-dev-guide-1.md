---
title: Google Tech Dev Guideのコーディング問題解いてみた（ついでに日本語訳も）
tags:
  - Google Tech Dev Guide
  - アルゴリズム
categories: 技術
featured_image: thumb.png
date: 2020-11-01 14:21:07
---


## 背景
こんにちは。 [かりんとうマニア(@karintozuki)](https://twitter.com/karintozuki)です。  
## Google Tech Dev Guideとは
Googleが提供しているコーディングにまつわるコースです。
こちらのリンクから元のサイトが見れます。（英語です。）
https://techdevguide.withgoogle.com/
<!-- more -->

ネット上のコーディングにまつわる題材をGoogleさんがチョイスして
ひとまとめにコースにした感じで、youtubeやらStack Overflowなどいろいろなところから教材がピックアップされています。

このブログではその中からコーディングチャレンジを抜粋して
日本語で解説しようと思います。
こちらから関連記事がまとめて見られます。
[Google Tech Dev Guideのコーディング問題解いてみた 記事一覧](/tags/Google-Tech-Dev-Guide/)

ちなみにこの１問目は割と難し目なので、２問目から始めるのも良いかもしれません。
[Google Tech Dev Guideのコーディング問題解いてみた〜その２（ついでに日本語訳も）](/2020/11/2020-1103-google-dev-guide-2/)


### Google Tech Dev Guideには日本語版がない。
本家のGoogle Tech Dev Guideには日本語の翻訳がありません。
なので、このブログではGoogle Tech Dev Guideの中でも
コーディングチャレンジを日本語で解説してみようと思っています。

## 問題
それでは、本題です。

> 文字列`S`と複数の単語`D`があります。
`D`の中で最長の`S`のサブシーケンスを見つけてください。

**サブシーケンスの定義**
文字列`S="abppple"`
`D={"able", "ale", "apple", "bale", "kangaroo"}`
だったときを考えます。

"able", "ale", "apple"はSのサブシーケンスです。
これらの単語に含まれる文字はSに含まれています。
また、それらの文字の出現する順番もSの中での順番と同じです。

"bale"はサブシーケンスになりません。
b,a,l,eはSに含まれる文字ですが、出現する順番が違うためです。
(Sの中でb以降にaは登場しません）

"kangaroo"はサブシーケンスではありません。
k,g,r,oはSに含まれないからです。

## 問題のねらい
アルゴリズムとデータ構造が勉強できます。
それと、計算量オーダー大事。
普通のケースと最悪のケースを想定することに気をつけましょう。

## ヒント
Googleさんがヒントを用意してくれています。
解答に詰まったら見てみましょう。

### ヒント１
ひとまず複数単語があることは忘れて、一つの単語がサブシーケンスかどうかを判定することだけ考えてみましょう。

### ヒント２
サブシーケンスかどうか判定できたら、それを最適化していきましょう。
`S`に事前処理をすることで効率的に処理できませんか？

### ヒント３
貪欲法を使ってみよう

### ヒント４
`W`=`D`内の単語数、`N`=`S`の文字数、`L`=`D`内の単語の文字数の合計、としたときに
`W * N`が`L`よりかなり大きい場合、どうしますか？
例えば、`D`,`S`を事前に処理するなどはできるでしょうか。

### ヒント５
`S`の文字数が`D`のサイズよりかなり大きい場合、どうしますか？

### ヒント６
事前処理したデータをどのデータ構造で処理しますか？
異なる構造を選んだ際のトレードオフは何でしょうか？
ツリー構造、ディクショナリーなどに収納できるデータはどれでしょうか。

## 解答
さて、実装できましたか？
いろいろな解放があるので、一つ一つ解説していきます。
解説では、以下の数値を使います。
- `W` = `D`内の単語数
- `N` = `S`の文字数
- `L` = `D`内の単語の文字数の合計

## 総当たり（ブルートフォース）
はじめに紹介されている方法は<u>総当たりでやる方法</u>です。
考えられる全てのサブシーケンスを生成して
`D`内の単語を一つ一つチェックしていきます。

計算量は`O(2^N)`になります。
ハッシュテーブルやプレフィックス木を使うことで効率をあげることができます。

まあ、これは力技ですな。

## 貪欲法
貪欲法を使用して`D`内の単語`w`が`S`のサブシーケンスかどうかを判別します。

まずは`w[0]`(単語の一文字目)を`S`の一文字目から順に探していきます。
`w[0]`が見つかったら、`S`内の次の文字から`w[1]`を探していきます。
これを繰り返し、
- `S`にこれ以上文字がなければ`w`はサブシーケンスではない
- `w`内の全部の文字を見つけられれば、`w`はサブシーケンスである

とサブシーケンスかどうかが判定できます。

実際のデータを使って説明してみます。
`S = "abppplee"`、`w = "ale"`の場合で考えてみます。
- ステップ１
`w[0] = 'a'`は`S`の１文字目に見つかりました。

- ステップ２
次に探す文字は`w[1] = 'l'`です。
`l`を`S`の２文字目以降から探していきます。
そうすると`w[1] = 'l'`は`S`の６文字目で見つかります。

- ステップ３
次に`w[3] = 'e'`を`S`の７文字目から探していきます。
`w[3] = 'e'`は`S`の7文字目に見つかります。

<u>`w`内の文字全てが見つかったので、`w`は`S`のサブシーケンスです。</u>

という感じでサブシーケンスの判定ができます。

`D`を<u>単語の長い順にソートしておけば、</u>
一番はじめに見つかったサブシーケンスが最長のサブシーケンスということになります。

### 計算量の考察
貪欲法での計算量を考えてみましょう。

`D`内の単語の単語数合計を`W`、
`S`の文字数を`N`とした際に、
一回のサブシーケンス判定の計算量は`S`をスキャンするために`O(N)`です。
それを`W`回だけ実行するので、全体の計算量は`O(N*W)`です。

これは`D`に含まれる単語の長さが`N`に近い時は最適に近い値になります。
最悪のケースとしては`S`が長い文字列で`D`に短い単語しか含まれない場合です。

例えば`w=abcdef`が`S=abcdefg`のサブシーケンスかどうかを調べる際は、貪欲法で良い気がします。
ですが、`w=z`が`S=abcdefg~(中略)~xyz`のサブシーケンスかどうか調べる際に貪欲法を用いると26回比較しないといけないため、非効率な気がします。

ここで`L`を`D`に含まれる単語の文字数の合計と定義します。
この場合、`O(N + L)`となるアルゴリズムがあれば一番効率がいいですね。
ただ、貪欲法のままだと、計算量は`O(N * L)`くらいになりそうです。

### 貪欲法とは
貪欲法という（少なくとも私は）聞き慣れない言葉が出てきました。
これは一般的に判断をする都度で最適な解を選択するアルゴリズムを指すそうです。

貪欲法を用いる処理は一回一回の選択は最適なものを選ぶけど、
処理全体を通しては最適かどうか分からない、ということになります。

この問題でも、対象の文字が`S`の中で見つかるかを調べるのには最適だけど、全体を通しての処理速度は最適ではない、ということになるでしょうか。
これ以降の方法では、`S`や`D`を事前処理することで、その都度の最適解ではなく、全体の最適化を目指します。

## 貪欲法の改善
`w`の中の文字`c`を`S`内で探す際には以下を満たす`i`を見つける必要があります。

- `S[i] = c`である
- この`i`は`j`（直前に見つけた文字のインデックス）より大きい

貪欲法はこの`i`を頭からスキャンするため遅くなっています。

これを解決するために`S`に事前処理をしてみましょう。
`S = "abppplee"`だった場合に、文字->[該当文字の`S`におけるインデックス]というマップを作ってみましょう。

```
a -> [0]
b -> [1]
p -> [2, 3, 4]
l -> [5]
e -> [6, 7]
```
これを使って`w = "ale"`が`S`のサブシーケンスかどうかを判定してみます。

- ステップ１
`w[0] = 'a'`をまずマップで探すと
`a -> [0]`が存在しているので、aは`S`に使われている文字です。
次にインデックスを確認します。
aは`w`の最初の文字なので、`0`で良いでしょう。

- ステップ２
`w[1] = 'l'`について、lはマップに存在しています。
`l -> [5]`
直前に見つかった文字のインデックスは`0`で
これより大きいインデックスが存在するか確認します。
そして、5が見つかりました。

- ステップ３
`w[2] = 'e'`について、eはマップに存在しています。
`e -> [6, 7]`
直前に見つかったインデックスは5で、それ以上のインデックスが存在するか確認します。ここでは6が存在していますね。

こうして`w = "ale"`内の全ての文字が見つかったので、サブシーケンスである、と言えます。

### 計算量の考察
このアプローチを使った場合の計算量を考えます。
直前に見つかった文字のインデックスより大きい数字が
存在するかどうかは二分探索を使うことで`O(LogN)`になります。
参考)バイナリサーチの計算量がO(log_2 n)となる理由
https://qiita.com/yz2cm/items/50abba2810c9bca0e780

なので、全体の計算量は`O(N + L * logN)`になります。

## アルファベットの数が少ない時の最適解
`S`に使われるアルファベットの種類が少ない時には
`O(N + L)`となる方法を紹介します。

正確には`O(N*A + L)`です。
`A`は`S`に使用できるアルファベットの種類で、a-zなら`A = 26`です。

この方法は`S`を事前処理する際に、
アルファベットごとにマップを作るところまでは同じですが、
<u>直近見つかった文字のインデックスを`j`としたときに
`マップ内の配列[j]`が、次にその文字が見つかるインデックスを返すようにします。</u>

また、直前に見つかった文字以降にその文字が存在しない時は`-1`を返します。

言葉で説明すると分かりづらいので、実例をみてみましょう。
`S = "abppplee"`を処理すると、以下のようになります。

```
a -> [0,-1,-1,-1,-1,-1,-1,-1]
b -> [1, 1,-1,-1,-1,-1,-1,-1]
p -> [2, 2, 3, 4,-1,-1,-1,-1]
l -> [5, 5, 5, 5, 5,-1,-1,-1]
e -> [6, 6, 6, 6, 6, 6, 7,-1]
```

これを`w = "ale"`に対して適用してみます。
- ステップ１
最初の文字は`a`なので、`a -> [0,-1,-1,-1,-1,-1,-1,-1]`をみます。
最初の文字なので、配列内の最初の値をチェックすると`a[0] = 0`です。

- ステップ２
次の文字は`l`なので、`l -> [5, 5, 5, 5, 5,-1,-1,-1]`をみます。
直近で見つかった文字のインデックスは`0`なので
返ってくる値は`l[0] = 5`です。

- ステップ３
次の文字は`e`なので、`e -> [6, 6, 6, 6, 6, 6, 7,-1]`をみます。
直近で見つかった文字のインデックスは`5`なので
返ってくる値は`e[5] = 6`です。
全ての文字が見つかったので、`w="ale"`は`S`のサブシーケンスです。

この方法はO(N*A)を事前処理に使うため、`A`の種類が多い場合は使えません。
例えばアルファベットだけでなく、日本語も許容した場合などは大変な計算量になりそうですね。

## アルファベットによらないO(N + L)
先ほどの方法はアルファベットの文字数に依存しましたが、
そうではない方法を紹介します。

この方法では`D`内の単語をまとめて処理します。

事前処理として、`D`を以下のようなデータ構造に収納します。
```
a -> [("able", 0), ("ale", 0), ("apple", 0)]
b -> [("bale", 0)]
k -> [("kangaroo", 0)]
```

マップのキーにあたる部分（ここではa,b,k）は次に`S`内で検索したい文字です。初期状態では各単語の１文字目になります。
配列内には(`w`=単語,`i`=最後に`S`で見つけた文字のカウント)を入れます。
初期状態ではどの文字も見つかっていないので、`i = 0`となっています。

ここから`S`をスキャンして、文字が見つかった場合は単語を次の文字のマップへ移動させ、`i`をインクリメントします。
`i`と単語の文字数が一致した場合、サブシーケンスとして他の配列に格納しておきます。
最終的に`S`をスキャンし終わって、サブシーケンス配列内で最長の文字列が答えになります。

実際にデータを変化させながらみてみましょう。

- ステップ１
`S`の一文字目は`a`です。`a[]`に含まれる単語を処理すると、
以下のようになります。
```
a -> []
b -> [("bale", 0), ("able", 1)]
l -> [("ale", 1)]
p -> [("apple", 1)]
k -> [("kangaroo", 0)]
```

- ステップ２
`S`の二文字目は`b`なので、`b[]`を処理します。
```
a -> [("bale", 1)]
b -> []
l -> [("ale", 1), ("able", 2)]
p -> [("apple", 1)]
k -> [("kangaroo", 0)]
```


- ステップ２
`S`の二文字目は`p`なので、`p[]`を処理します。
```
a -> [("bale", 1)]
b -> []
l -> [("ale", 1), ("able", 2)]
p -> [("apple", 2)]
k -> [("kangaroo", 0)]
```

- ステップ３
`S`の二文字目は`p`なので(ry
```
a -> [("bale", 1)]
b -> []
l -> [("ale", 1), ("able", 2), ("apple", 3)]
p -> []
k -> [("kangaroo", 0)]
```
- ステップ４
`S`の次は`p`なので(ry
```
a -> [("bale", 1)]
b -> []
l -> [("ale", 1), ("able", 2), ("apple", 3)]
p -> []
k -> [("kangaroo", 0)]
```
今回は`p[]`が存在しないので、変化ないですね。


- ステップ４
次は`l`(ry
```
a -> [("bale", 1)]
b -> []
e -> [("ale", 2), ("able", 3), ("apple", 4)]
l -> []
p -> []
k -> [("kangaroo", 0)]
```

- ステップ５
次は`e`(ry
```
a -> [("bale", 1)]
b -> []
e -> []
l -> []
p -> []
k -> [("kangaroo", 0)]

// サブシーケンスと判定した文字列を格納する配列
subsequences[("ale", 3), ("able", 4), ("apple", 5)]
```

という具合で、サブシーケンスの単語が全部洗い出されました！
この方法なら計算量は`O(N + L)`になりますね！

## まとめ
いかがでしたか？

これらの問題を考える上でのポイントは
計算量を考えることでより良いアルゴリズムにたどり着けるようですね。
また、最悪のケースを考えることで、それが効率的かどうかを判定できるということのようです。

私は今まで計算量などあまり考えずに実装をしていたのですが、
最後の二つの方法とかはどんな人生をあゆんだら思いつくのでしょうか。。。

Google Tech Dev Guideの他の教材も勉強しながら精進していきたいです。

それじゃ今日はこの辺で。

## 関連記事
こちらの記事もおすすめです。  
[Spring BootでLINE Botのサンプルを動かす 〜おうむ返しのその先へ〜](/2020/04/2020-0408-linebot/)


## PR
あなたの会社はあなたの技術を評価してくれていますか？
技術力を高めようと頑張っているのに、
技術が評価されないような会社にいたらそれは良い環境なのでしょうか？
エンジニアとして技術を高めたいのなら環境を選ぶことも大事です。

**レバテックキャリア**
エンジニアとして働いていて実務経験があるなら、
求人数の充実具合からレバテックキャリアがおすすめです。
<u>IT転職ではデファクト・スタンダード</u>ですね。
[▼レバテック　キャリア 登録はこちら▼](https://px.a8.net/svt/ejp?a8mat=3H3JXF+8PRGKY+2JK4+ZRIB5 )
<a href="https://px.a8.net/svt/ejp?a8mat=3H3JXF+8PRGKY+2JK4+ZWFS1" rel="nofollow">
<img border="0" width="728" height="90" alt="" src="https://www22.a8.net/svt/bgt?aid=210117795527&wid=001&eno=01&mid=s00000011866006030000&mc=1"></a>
<img border="0" width="1" height="1" src="https://www13.a8.net/0.gif?a8mat=3H3JXF+8PRGKY+2JK4+ZWFS1" alt="">

**Tech Clips**
Tech Clipsは<u>年収500万以上＆自社サービスを持った会社</u>に特化した求人サイトです。
首都圏限定になってはしまいますが、
収入を増やしたい、自社サービスを持った企業への転職をしたい人におすすめです。

[▼Tech Clips 登録はこちら▼](https://px.a8.net/svt/ejp?a8mat=3H3JXF+DE94S2+3SWM+61Z81)
<a href="https://px.a8.net/svt/ejp?a8mat=3H3JXF+DE94S2+3SWM+61Z81" rel="nofollow">
<img border="0" width="300" height="250" alt="" src="https://www20.a8.net/svt/bgt?aid=210117795810&wid=001&eno=01&mid=s00000017743001017000&mc=1"></a>
<img border="0" width="1" height="1" src="https://www12.a8.net/0.gif?a8mat=3H3JXF+DE94S2+3SWM+61Z81" alt="">
